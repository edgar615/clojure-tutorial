(class (inc (Integer. 5)))
;;java.lang.Long

;数字操作的语义在不同类型之间以及操作不同类型的数字时都是一致的。
(dec 1)
;;0
(dec 1.0)
;;0.0
(dec 1N)
;;0N
(dec 1M)
;;0M
(dec 5/4)
;;1/4

;可以自由地在一个操作里混合使用不同类型的数字
(* 3 0.08 1/4 6N 1.2M)
;;0.432
(< 1 1.6 7/3 9N 14e9000M)
;;true

;有理数
;有理数可以表示为两个整数的分数的数字的集合
;1/3和3/5都是有理数

(+ 0.1 0.1 0.1)
;;0.30000000000000004
(+ 1/10 1/10 1/10)
;;3/10

(+ 7/10 1/10 1/10 1/10)
;;1N

;;比例数可以明确地强制转换为浮点表示
(double 1/3)
;;0.3333333333333333

;而浮点数也可以用rationalize函数转换为一个比例数
(rationalize 0.45)
;;9/20

;数字传播规则
;当一个算术操作涉及不同类型的数字时，操作返回值的类型由一个固定的层级决定。
;每种数字类型传播的程度各不相同，操作的参数传播度最高的一个决定返回值的类型。
; long -> BigInt -> Rationals -> BigDecimal -> double
;每个数字操作都必须返回某个具体类型的值，并且当操作涉及不同类型的参数时，
;必须定义一个方法来选取操作的类型。
;Clojure定义的具体层级是有顺序的，层级的实现永远不会让返回值的类型强制是“有损的”，
;例如米格long可以强制为big int或rationals或decimal而不影响语义，相反却不成立
;;操作于同一类型的参数返回那个类型的结果
(+ 1 1)
;;2
;;操作涉及long和double总会返回一个double类型
(+ 1 1.5)
;;2.5
;;操作涉及long和BigInteger综合返回一个BigInteger类型
(+ 1 1N)
;;2N
;;操作涉及BigDecimal和BigInteger总会返回一个BigDecimal类型
(+ 1.1M 1N)
;;2.1M

;这里唯一的问题是任何涉及double的都会返回double类型，即使double不能正确地表示其他数值表示的全部范围。
;这是因为：
;1.double定义了一些特别值，这些值不能表示为BigDecimal(特别是Infinity和NaN两个值)
;2.double是唯一一个天生就不精确的表示——一个涉及不精确数数字的操作返回一个暗示精确但实际不精确的类型值是有问题的
